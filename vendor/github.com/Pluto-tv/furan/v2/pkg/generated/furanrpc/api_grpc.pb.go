// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.24.3
// source: api.proto

package furanrpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	FuranExecutor_StartBuild_FullMethodName     = "/furanrpc.FuranExecutor/StartBuild"
	FuranExecutor_GetBuildStatus_FullMethodName = "/furanrpc.FuranExecutor/GetBuildStatus"
	FuranExecutor_GetBuildEvents_FullMethodName = "/furanrpc.FuranExecutor/GetBuildEvents"
	FuranExecutor_MonitorBuild_FullMethodName   = "/furanrpc.FuranExecutor/MonitorBuild"
	FuranExecutor_CancelBuild_FullMethodName    = "/furanrpc.FuranExecutor/CancelBuild"
	FuranExecutor_ListBuilds_FullMethodName     = "/furanrpc.FuranExecutor/ListBuilds"
)

// FuranExecutorClient is the client API for FuranExecutor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FuranExecutorClient interface {
	StartBuild(ctx context.Context, in *BuildRequest, opts ...grpc.CallOption) (*BuildRequestResponse, error)
	GetBuildStatus(ctx context.Context, in *BuildStatusRequest, opts ...grpc.CallOption) (*BuildStatusResponse, error)
	GetBuildEvents(ctx context.Context, in *BuildStatusRequest, opts ...grpc.CallOption) (*BuildEventsResponse, error)
	MonitorBuild(ctx context.Context, in *BuildStatusRequest, opts ...grpc.CallOption) (FuranExecutor_MonitorBuildClient, error)
	CancelBuild(ctx context.Context, in *BuildCancelRequest, opts ...grpc.CallOption) (*BuildCancelResponse, error)
	ListBuilds(ctx context.Context, in *ListBuildsRequest, opts ...grpc.CallOption) (*ListBuildsResponse, error)
}

type furanExecutorClient struct {
	cc grpc.ClientConnInterface
}

func NewFuranExecutorClient(cc grpc.ClientConnInterface) FuranExecutorClient {
	return &furanExecutorClient{cc}
}

func (c *furanExecutorClient) StartBuild(ctx context.Context, in *BuildRequest, opts ...grpc.CallOption) (*BuildRequestResponse, error) {
	out := new(BuildRequestResponse)
	err := c.cc.Invoke(ctx, FuranExecutor_StartBuild_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *furanExecutorClient) GetBuildStatus(ctx context.Context, in *BuildStatusRequest, opts ...grpc.CallOption) (*BuildStatusResponse, error) {
	out := new(BuildStatusResponse)
	err := c.cc.Invoke(ctx, FuranExecutor_GetBuildStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *furanExecutorClient) GetBuildEvents(ctx context.Context, in *BuildStatusRequest, opts ...grpc.CallOption) (*BuildEventsResponse, error) {
	out := new(BuildEventsResponse)
	err := c.cc.Invoke(ctx, FuranExecutor_GetBuildEvents_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *furanExecutorClient) MonitorBuild(ctx context.Context, in *BuildStatusRequest, opts ...grpc.CallOption) (FuranExecutor_MonitorBuildClient, error) {
	stream, err := c.cc.NewStream(ctx, &FuranExecutor_ServiceDesc.Streams[0], FuranExecutor_MonitorBuild_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &furanExecutorMonitorBuildClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FuranExecutor_MonitorBuildClient interface {
	Recv() (*BuildEvent, error)
	grpc.ClientStream
}

type furanExecutorMonitorBuildClient struct {
	grpc.ClientStream
}

func (x *furanExecutorMonitorBuildClient) Recv() (*BuildEvent, error) {
	m := new(BuildEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *furanExecutorClient) CancelBuild(ctx context.Context, in *BuildCancelRequest, opts ...grpc.CallOption) (*BuildCancelResponse, error) {
	out := new(BuildCancelResponse)
	err := c.cc.Invoke(ctx, FuranExecutor_CancelBuild_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *furanExecutorClient) ListBuilds(ctx context.Context, in *ListBuildsRequest, opts ...grpc.CallOption) (*ListBuildsResponse, error) {
	out := new(ListBuildsResponse)
	err := c.cc.Invoke(ctx, FuranExecutor_ListBuilds_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FuranExecutorServer is the server API for FuranExecutor service.
// All implementations should embed UnimplementedFuranExecutorServer
// for forward compatibility
type FuranExecutorServer interface {
	StartBuild(context.Context, *BuildRequest) (*BuildRequestResponse, error)
	GetBuildStatus(context.Context, *BuildStatusRequest) (*BuildStatusResponse, error)
	GetBuildEvents(context.Context, *BuildStatusRequest) (*BuildEventsResponse, error)
	MonitorBuild(*BuildStatusRequest, FuranExecutor_MonitorBuildServer) error
	CancelBuild(context.Context, *BuildCancelRequest) (*BuildCancelResponse, error)
	ListBuilds(context.Context, *ListBuildsRequest) (*ListBuildsResponse, error)
}

// UnimplementedFuranExecutorServer should be embedded to have forward compatible implementations.
type UnimplementedFuranExecutorServer struct {
}

func (UnimplementedFuranExecutorServer) StartBuild(context.Context, *BuildRequest) (*BuildRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartBuild not implemented")
}
func (UnimplementedFuranExecutorServer) GetBuildStatus(context.Context, *BuildStatusRequest) (*BuildStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBuildStatus not implemented")
}
func (UnimplementedFuranExecutorServer) GetBuildEvents(context.Context, *BuildStatusRequest) (*BuildEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBuildEvents not implemented")
}
func (UnimplementedFuranExecutorServer) MonitorBuild(*BuildStatusRequest, FuranExecutor_MonitorBuildServer) error {
	return status.Errorf(codes.Unimplemented, "method MonitorBuild not implemented")
}
func (UnimplementedFuranExecutorServer) CancelBuild(context.Context, *BuildCancelRequest) (*BuildCancelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelBuild not implemented")
}
func (UnimplementedFuranExecutorServer) ListBuilds(context.Context, *ListBuildsRequest) (*ListBuildsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBuilds not implemented")
}

// UnsafeFuranExecutorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FuranExecutorServer will
// result in compilation errors.
type UnsafeFuranExecutorServer interface {
	mustEmbedUnimplementedFuranExecutorServer()
}

func RegisterFuranExecutorServer(s grpc.ServiceRegistrar, srv FuranExecutorServer) {
	s.RegisterService(&FuranExecutor_ServiceDesc, srv)
}

func _FuranExecutor_StartBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FuranExecutorServer).StartBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FuranExecutor_StartBuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FuranExecutorServer).StartBuild(ctx, req.(*BuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FuranExecutor_GetBuildStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FuranExecutorServer).GetBuildStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FuranExecutor_GetBuildStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FuranExecutorServer).GetBuildStatus(ctx, req.(*BuildStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FuranExecutor_GetBuildEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FuranExecutorServer).GetBuildEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FuranExecutor_GetBuildEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FuranExecutorServer).GetBuildEvents(ctx, req.(*BuildStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FuranExecutor_MonitorBuild_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BuildStatusRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FuranExecutorServer).MonitorBuild(m, &furanExecutorMonitorBuildServer{stream})
}

type FuranExecutor_MonitorBuildServer interface {
	Send(*BuildEvent) error
	grpc.ServerStream
}

type furanExecutorMonitorBuildServer struct {
	grpc.ServerStream
}

func (x *furanExecutorMonitorBuildServer) Send(m *BuildEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _FuranExecutor_CancelBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildCancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FuranExecutorServer).CancelBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FuranExecutor_CancelBuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FuranExecutorServer).CancelBuild(ctx, req.(*BuildCancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FuranExecutor_ListBuilds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBuildsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FuranExecutorServer).ListBuilds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FuranExecutor_ListBuilds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FuranExecutorServer).ListBuilds(ctx, req.(*ListBuildsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FuranExecutor_ServiceDesc is the grpc.ServiceDesc for FuranExecutor service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FuranExecutor_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "furanrpc.FuranExecutor",
	HandlerType: (*FuranExecutorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartBuild",
			Handler:    _FuranExecutor_StartBuild_Handler,
		},
		{
			MethodName: "GetBuildStatus",
			Handler:    _FuranExecutor_GetBuildStatus_Handler,
		},
		{
			MethodName: "GetBuildEvents",
			Handler:    _FuranExecutor_GetBuildEvents_Handler,
		},
		{
			MethodName: "CancelBuild",
			Handler:    _FuranExecutor_CancelBuild_Handler,
		},
		{
			MethodName: "ListBuilds",
			Handler:    _FuranExecutor_ListBuilds_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MonitorBuild",
			Handler:       _FuranExecutor_MonitorBuild_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}
